权限是 web 设计中的重要组成部分。没有权限控制，任何人都可以对任何资源进行危险的操作，那就太恐怖了。本章来看看 REST 框架是如何进行权限管理的。

## 文章与用户

由于要给文章模型添加非空的用户外键，所以首先删除现有的所有文章。

修改文章的 model，让每篇文章都对应一个确定的用户：

```python
# article/models.py

...

from django.contrib.auth.models import User

class Article(models.Model):
    author = models.ForeignKey(
        User, 
        null=True,
        on_delete=models.CASCADE, 
        related_name='articles'
    )
    ...
```

执行迁移：

```python
> python manage.py makemigrations
> python manage.py migrate
```

启动服务器后，查看当前文章列表：

```python
> http http://127.0.0.1:8000/api/article/
        
HTTP/1.1 200 OK
...

[]
```

空空如也。接下来就拿文章列表接口开刀，进行权限管理工作。

## 权限控制

REST 框架内置了如 `IsAuthenticated`、`IsAdminUser`、`AllowAny` 等权限控制类。

由于是个人博客，因此只准许管理员发布文章。修改文章列表视图如下：

```python
# article/views.py

...
from rest_framework.permissions import IsAdminUser

class ArticleList(generics.ListCreateAPIView):
    ...
    # 新增
    permission_classes = [IsAdminUser]
```

测试一下：

```python
> http http://127.0.0.1:8000/api/article/
HTTP/1.1 403 Forbidden
...
{
    "detail": "Authentication credentials were not provided."
}


> http POST http://127.0.0.1:8000/api/article/ title=may body=notSuccess
HTTP/1.1 403 Forbidden
...
{
    "detail": "Authentication credentials were not provided."
}
```

倒是确实起作用的，但是除了管理员之外其他人连查看都没权限了，显示这不是我们想要的。

好在自定义一个权限类也不难。在文章 app 中创建 `article/permissions.py` 文件，写入以下代码：

```python
# article/permissions.py

from rest_framework import permissions

class IsAdminUserOrReadOnly(permissions.BasePermission):
    """
    仅管理员用户可进行修改
    其他用户仅可查看
    """
    def has_permission(self, request, view):
        # 对所有人允许 GET, HEAD, OPTIONS 请求
        if request.method in permissions.SAFE_METHODS:
            return True

        # 仅管理员可进行其他操作
        return request.user.is_superuser
```

自定义的权限类继承了 `BasePermission` 这个基础的父类，并实现了父类中的钩子方法 `def has_permission`。方法里简单判断了一下请求的种类是否安全（即对数据不更改的请求类型），如果安全则直接通过，不安全则只允许超级用户通过。

再次修改视图：

```python
# article/views.py

...

# from rest_framework.permissions import IsAdminUser
from article.permissions import IsAdminUserOrReadOnly

class ArticleList(generics.ListCreateAPIView):
    ...
    permission_classes = [IsAdminUserOrReadOnly]

# 顺便把详情视图的权限也更改了
class ArticleDetail(generics.RetrieveUpdateDestroyAPIView):
    ...
    permission_classes = [IsAdminUserOrReadOnly]
```

这就可以了。

首先在命令行测试一下**用户未登录**时的情况：

```python
> http http://127.0.0.1:8000/api/article/
# GET 请求成功
HTTP/1.1 200 OK
...
[]


> http POST http://127.0.0.1:8000/api/article/ title="post with permission" body="new test"
# POST 请求失败
HTTP/1.1 403 Forbidden
...
{
    "detail": "Authentication credentials were not provided."
}
```

在后台中创建一个普通用户 **Obama**（这也是基础，不懂还是参考[这篇文章](https://www.dusaiphoto.com/article/detail/15/#superuser)），用普通用户身份进行请求：

```python
# 普通用户 Obama，密码 admin123456

> http -a Obama:admin123456 http://127.0.0.1:8000/api/article/
# GET 请求成功
HTTP/1.1 200 OK
...
[]


> http -a Obama:admin123456 POST http://127.0.0.1:8000/api/article/ title="post with permission" body="new test"
# POST 请求失败    
HTTP/1.1 403 Forbidden
...
{
    "detail": "You do not have permission to perform this action."
}
```

最后，再用管理员用户 dusai 测试：

```python
# 管理员用户 dusai，密码 admin123456

> http -a dusai:admin123456 http://127.0.0.1:8000/api/article/
# GET 请求成功
HTTP/1.1 200 OK
...
[]


> http -a dusai:admin123456 POST http://127.0.0.1:8000/api/article/ title="post with permission" body="new test"
# POST 请求成功
HTTP/1.1 201 Created
...
{
    "created": "2020-07-03T04:56:26.869523Z",
    "id": 2,
    "title": "post with permission"
}
```

对特定文章的操作也是相同的。对资源不进行修改的操作，任何人都可以；但是涉及到如新增（CREATE）、更新（PUT）、删除（DELETE）等操作就只允许管理员执行。