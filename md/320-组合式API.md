前面的 Vue 章节，可以说是基础，也是对 Vue 2 光荣一生的回顾。

本章作为教程的尾声，将开始进入 Vue 3 最强大的新功能之一：组合式 API 。

## 什么是组合式API

**非常建议**大家先去读读[官方文档](https://v3.cn.vuejs.org/guide/composition-api-introduction.html)，把组合式 API 的涵义和作用讲得非常的清楚了。总结成几句话就是：

- Vue 2 能够很好的胜任任何中小型项目，但是对于超大型项目（几百个以上的组件）有天生的缺陷，最显著的矛盾是**逻辑关注点分离**：你可能很难短时间分清哪些方法在操作哪些数据、哪些变量又被哪些组件所更改了。
- 组合式 API 将相同逻辑关注点代码聚合在了一起，并且很自然的支持代码复用。

话不多说，接下来让我们将文章列表页面 `ArticleList.vue` 的**选项式API**进化为**组合式API**，用例子感受吧。

## 起步

本章的所有修改只涉及到 `ArticleList.vue` 的 Javascript 脚本部分，因此先把旧代码先贴出来：

```javascript
import axios from 'axios';

export default {
    name: 'ArticleList',
    data: function () {
        return {
            info: ''
        }
    },
    mounted() {
        this.get_article_data()
    },
    methods: {
        imageIfExists(article) {
            if (article.avatar) {
                return article.avatar.content
            }
        },
        gridStyle(article) {
            if (article.avatar) {
                return {
                    display: 'grid',
                    gridTemplateColumns: '1fr 4fr'
                }
            }
        },
        formatted_time: function (iso_date_string) {
            const date = new Date(iso_date_string);
            return date.toLocaleDateString()
        },
        is_page_exists(direction) {
            if (direction === 'next') {
                return this.info.next !== null
            }
            return this.info.previous !== null
        },
        get_page_param: function (direction) {
            try {
                let url_string;
                switch (direction) {
                    case 'next':
                        url_string = this.info.next;
                        break;
                    case 'previous':
                        url_string = this.info.previous;
                        break;
                    default:
                        return this.$route.query.page
                }

                const url = new URL(url_string);
                return url.searchParams.get('page')
                // const page = url.searchParams.get('page');
                // return (page !== null) ? page : 1
            }
            catch (err) {
                return
            }
        },
        get_path: function (direction) {
            let url = '';

            try {
                switch (direction) {
                    case 'next':
                        if (this.info.next !== undefined) {
                            url += (new URL(this.info.next)).search
                        }
                        break;
                    case 'previous':
                        if (this.info.previous !== undefined) {
                            url += (new URL(this.info.previous)).search
                        }
                        break;
                }
            }
            catch {
                return url
            }

            return url
        },
        get_article_data: function () {
            let url = '/api/article';

            let params = new URLSearchParams();
            params.appendIfExists('page', this.$route.query.page);
            params.appendIfExists('search', this.$route.query.search);

            const paramsString = params.toString();
            if (paramsString.charAt(0) !== '') {
                url += '/?' + paramsString
            }

            axios
                .get(url)
                .then(response => (this.info = response.data))
        }
    },
    watch: {
        $route() {
            this.get_article_data()
        }
    }
}
```

很熟悉对吧，下面开始魔改。

要使用组合式 API，首先要有个入口，就是 Vue 3 的 `setup()` 函数：

```javascript
export default {
    name: '...',

    // 组合式 APi 入口
    setup() {
        return {}
    },
    
    // 其他代码
    ...
}
```

这就是一个最简单了 `setup()` 了。

**注意：**Vue 执行 `setup()` 的时机非常早，此时 Vue 的实例都尚未生成，因此在 `setup` 中没有 `this`。这意味着除了 `props` 之外，你将无法访问组件中的任何属性：**数据**、**计算属性**或**方法**。

现在我们想把本地数据 `info` 移动到 `setup()` 里，像下面这样做：

```javascript
import { ref } from 'vue'

export default {
    setup() {
        const info = ref('');
        
        return {
            info,
        }
    },

    // 旧代码的状态数据，注释掉
    // data: function () {
    //     return {
    //         info: ''
    //     }
    // },
}
```

- 你不能普通的如 `let info = ''` 声明状态，这不是**响应式**的，而是个普通的字符串。因此用 Vue 3 提供的 `ref` 将其包装成一个响应式的对象，和旧的 `data` 一样。
- 用 `return` 将状态数据返回，Vue 就会将其注入到实例的 `this` 中。

刷新下页面，功能应该无任何变化才对。

## 获取数据

只把状态的位置挪动一下没什么意思，下面试试把获取数据的 `get_article_data()` 方法也改为组合式 API。

改动部分如下：

```javascript
import { ref } from 'vue'
import { useRoute } from 'vue-router'

export default {
    setup() {
        const info = ref('');

        const route = useRoute();

        const get_article_data = function () {
            let url = '/api/article';

            let params = new URLSearchParams();
            params.appendIfExists('page', route.query.page);
            params.appendIfExists('search', route.query.search);

            const paramsString = params.toString();
            if (paramsString.charAt(0) !== '') {
                url += '/?' + paramsString
            }

            axios
                .get(url)
                .then(response => (info.value = response.data))
        };

        return {
            info,
            get_article_data
        }
    },
    methods: {
        // get_article_data: function () {
        //     let url = '/api/article';
        //
        //     let params = new URLSearchParams();
        //     params.appendIfExists('page', this.$route.query.page);
        //     params.appendIfExists('search', this.$route.query.search);
        //
        //     const paramsString = params.toString();
        //     if (paramsString.charAt(0) !== '') {
        //         url += '/?' + paramsString
        //     }
        //
        //     axios
        //         .get(url)
        //         .then(response => (this.info = response.data))
        // }
    },
}
```

看起来只是把方法挪了个地方并变得更拗口了而已，但是里面有一些很**重要**的区别：

- 由于 `setup()` 里没有 `this` ，自然 `this.$route` 也不能用，必须用 vue-router 的 `userRoute()` 方法创建路由对象。（类似的还有 `userRouter()` ）。所有用到 `this` 的地方都进行了对应的修改。
- 用 `ref.value` 可访问到响应式对象中实际保存的内容，比如 `info.value` 。
- 用 `return` 将方法返回。

用到 `get_article_data()` 有两个地方，分别是 `mounted()` 和 `watch` ，我们把它两兄弟也搬到 `setup()` 中：

```javascript
import { ref, onMounted, watch } from 'vue'
import { useRoute } from 'vue-router'

export default {
    setup() {
        const info = ref('');

        const route = useRoute();

        const get_article_data = function () {...};

        onMounted(get_article_data);
        watch(route, get_article_data);

        return {
            info
        }
    },
    // mounted() {
    //     this.get_article_data()
    // },
    // watch: {
    //     $route() {
    //         this.get_article_data()
    //     }
    // }     
}
```

`setup` 中同样不能直接访问生命周期方法和监听方法，因此 Vue 3 提供了 `onMounted` 、 `watch` 作为对应的替代。

> 由于 setup 外不在关注 get_article_data() 方法，因此可以不用返回它了。
>
> 此外 `watch(route, ...)` 可能导致潜在的性能问题（控制台警告提示），不过教程为保持简单就不深究于此。有关此问题的讨论见[vue-next issues](https://github.com/vuejs/vue-next/issues/2027)。

## 可复用模块

到目前为止都没什么特别的，代码量似乎还更多了。接下来我们试试将这一堆相关的功能抽离成独立的 JS 模块。

新建 `frontend/src/composables/getArticleData.js` 文件，将 `get_article_data()` 方法挪进来：（有改动）

```javascript
// frontend/src/composables/getArticleData.js

import axios from 'axios';

export default function getArticleData(info, route) {
    let url = '/api/article';

    let params = new URLSearchParams();
    params.appendIfExists('page', route.query.page);
    params.appendIfExists('search', route.query.search);

    const paramsString = params.toString();
    if (paramsString.charAt(0) !== '') {
        url += '/?' + paramsString
    }

    axios
        .get(url)
        .then(response => (info.value = response.data))
}
```

注意这里有个**重要的改动**：

- 函数通过参数将响应式对象 `info` 、 `route` 传递进来，以便更新其中所包含的值。由此可见，`ref` 创建的是一个**响应式引用**。你可以在整个程序中安全地传递它，而不必担心在某个地方失去它的响应性。

> 你不能在函数体内部重新创建一个 info，那并不是 setup 中原始的对象，所以任何修改都是无效的。

接着再来修改 `setup()`：

```javascript
// frontend/src/components/ArticleList.vue


// 注释掉 axios
// import axios from 'axios';

import {ref, onMounted, watch} from 'vue'
import {useRoute} from 'vue-router'
import getArticleData from '@/composables/getArticleData.js'

export default {
    setup() {
        const info = ref('');

        const route = useRoute();

        const get_article_data = () => {
            getArticleData(info, route)
        };

        onMounted(get_article_data);
        watch(route, get_article_data);

        return {
            info
        }
    },
    ...
}
```

- 将 `get_article_data` 写为一个闭包，以捕获响应式对象 `info` 和 `route`。
- 不再需要 axios ，将其注释掉。

刷新页面，功能正常无变化。

update1